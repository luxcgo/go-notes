the following content is provided under a Creative Commons license your support will help MIT OpenCourseWare continue to offer high quality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu okay so today we're going to continue talking about multi-hop networks and in particular I'm going to talk about a fairly fundamental problem in multi health networks called network routing and that's the topic for today and for threw through most of half of next week and today this week we'll talk about network routing in networks where there are no failures so you know in real networks of course things fail packets get dropped nodes may fail switches may fail links may fail we'll just worry about the case when there are no failures for this week next week we'll add some more complexity and talk about how we deal with failures so the abstract problem is pretty simple you have a set of nodes in the network and there's some network topology and every source in the network you know you have sources and you have destinations loads in the network and they wish to send packets to each other and we're going to decompose this problem these endpoints which actually want you to want to communicate with each other as we've already talked about do so by sending packets via switches and the problem we're going to worry about is what happens inside the network in these switches the switches solved the following problem if things work correctly and if things work well when a switch receives a packet with the destination address specifying that that packet has to be sent to a particular named destination in the network the switch figures are how to ship that packet it figures out whether to send it along I need a better topology here it's sugarstar this switch for example figures out whether a package should go along that link or this link or this link or this link or that link given any packet that receives and every switch in the network performs this task now when a switch gets a packet and the packet has the destination address in it what the switch does is some sort of a lookup it looks up that destination in some sort of a table and that table maintains information about which of the links to use in sending that packet toward the destination and this step is called forwarding packets are forwarded by switches technically packets aren't routed everybody says packet routing and I say too but it's important to realize packets aren't drought at packets are forwarded the fumbling process is pretty straightforward at slow speeds you get a packet you take the destination you look up that packet in a table and that table tells you what you do with the packet which link to use routing is the problem that the switch is solved of constructing these tables so forwarding is simply look up in a table and the table is called the routing table sometimes it's also called the forwarding table and there's a technical difference between them that's not that important for us so forwarding is the process of looking up the destination in the routing table routing is the distributed process the algorithm that's used or the protocol that's used to build up these routing tables so it's the construction process how to construct these routing tables at each switch in the network that's done in the background that's usually done in software switches that high-speeds involve a fair amount of hardware routing itself is usually done in software and so a typical switch you know has a lot of different processing elements in it a lot of those processing elements are high speed hardware that deals with the process of forwarding and then you have software sitting on the side where all of the complexity is and all that complexity deals with all sorts of complicated rules that you have to come up with in order to decide how to construct these routing tables and we're going to talk about the world's simplest networks today where and you'll find that even that's reasonably sophisticated and complicated so just for concreteness an example of a picture of a topology is like this and for reasons that will become apparent as we talk this through will model the network as a set of nodes and a set of links and so far there's nothing new about this but will model links as having the cost and this cost might reflect for example the delay or latency to send a packet along that link the cost might reflect the real dollar cost of shipping data along links internet service providers might charge different amounts of money for different types of data for example well the cost might just reflect your own internal preferences as to which links you might prefer based on whatever concerns maybe some links are slow and some links are fast maybe they're higher speed link slower speed links that cost more or less etc so these costs are abstract numbers and we'll just assume that we're interested in finding minimum cost paths between senders and receivers so every switch solves the problem of finding the minimum cost path to a destination where the cost along a path is simply the sum of the costs along the links on that path this is just standard shortest path routing will use shortest paths even though we don't mean literally the shortest number of hops but the minimum cost path and where that distinction is important between the number of hops and the cost etc we'll five so if there aren't cable looks something like this in fact it looks like this there's destination every switch has this so this is an example of a round table at load B node B maintains all the destinations in the network and we're dealing with small networks so far in our class so we'll just assume that every node in the network has a unique name or a unique address and that the destination that the routing tables contain an entry for every destination in the network so the arm table has three columns it's a database with three columns and every switch in the network or a node I'm going to use the word node and switch interchangeably every switch or node in the network has one of these if the network is working correctly so if there aren't protocol that what does this job every node comes up with its own version of this table there's a destination there's the link you need to use that is the next hop if you get a packet to this destination what link would you use and a cost so in this table if node B or switch B received a packet destined for destination a it would use link l1 each link is named locally so B would have its own l0 l2 and l1 you know your own computer has a bunch of links if you do I don't know how what the command is in Windows but in all other sensible platforms if you do I have conveyed you can you can get I think it's called IP config under windows but you can actually see a list of links so switches have many many many links and so you'll find for example for destination a you use link l1 the cost is 18 in fact you'll see here that when when B receives a packet for a it doesn't use the direct link because the direct link has a cost of 19 whereas going through l1 this link has the cost of 11 and if it believes if B believes that this the path toward a along this link has a cost of elemental 7 is 18 that's what it thinks and therefore it would use that link okay it's very simple now routing is the process by which these different nodes talk to each other and build up these tables when I say a route to a destination I mean this I mean the route to a destination at a switch or at a node is the link that that destination would use to send packets to the destination this is important technically for us because otherwise we will get all tangled up getting confused between routes and paths okay for the purposes of our discussion a route is the next hop link is the link that you're going to use to get to the destination the path is a sequence of links so I don't want people telling me that the route from B to E is whatever ever it is BCE I'd like people to tell me that the route act destiny node B to destination e is l1 or if you wish to be clear you can say it's link l1 which takes it to the next hop see the path from B to E might be BCE okay all right so that's what the routing table structure looks like and we're interested in minimum cost our paths to go from places to places so you know normally traditionally we sit around and try to now dive into protocols but I think here what we're going to do is since our notes are also nice and written up I actually don't have to tell you everything that's there so what we're actually going to do is something we call the routing game which is an experiment in social networking like what it means is that each of you or some of you will act as nodes and start computing routes to different destinations okay so that's what this game is going to be so what I have in my hand is 40 slips of paper and I hope there are 40 people here 40 slips of paper and each of these paper slips of paper has some information that looks like this it says you are node X and you're connected to nodes Y Z W etc okay and there's a set of rules that I will go through in a minute first of all these were all in perfect order so I need to shuffle them a few times carefully without losing them I think persi diaconis is famous probabilistic said that you got to do the seven times okay so what I'm going to do is I'm gonna pass this around there's no bag here the bag is cumbersome so what I'd like you to do actually I'll put it in the envelope and pass it around just kind of close your eyes or something don't look at the number and just pick one up and don't look at it until I tell you okay so we start here and just pass it around I'd like you know 40 different people to have them you don't you don't have to feel compelled to take it but just pass it around and try to do it quickly because I'd like that to happen faster than the time it's going to take for us to compute these routes so why don't you just pick one sheet of paper up and just pass it around please okay so though you know I picked seven minutes sometimes works a little faster than seven the best that the class is down is about five minutes and sometimes last term they did it very quickly but they got it wrong so I don't think that counts but I've been told that they've tried this experiment Berkeley has taken usually more than seven minutes and I figure MIT students are smarter so let's see if you can do it faster than seven minutes now your job is to find a path from a source node to a destination or as quickly as possible okay and I mean as a bonus if you actually find the path with the minimum number of hops that's even better but we'll take any pack now there's some rules here now there are some rules here so you may not actually kind of get up and run around and try to you know do things that a normal network switch wouldn't do so you're allowed to stay in one place and what you're actually allowed to do is you're not allowed to pass your sheet of paper to other people because you know you have information about yourself and that piece tells you who your neigh​bors are the numbers of your neigh​bors so you can't actually kind of copy the Ascend your piece of paper to other nodes that's not allowed and don't don't let people copy what's on your sheet of paper now here's some things you can do you can read them ask your friends for advice you can shout to other participants we're allowing you to you know yell and scream but do so in a way that's somewhat civilized and you know if you can wish that you didn't pick up a slip or pick up a slip or whatever but you know try to act generally I mean this class is recorded so you know what you say might be heard now if you get to sleep a slip there's some ground rules you can't cheat like you know we're not dealing with security here's where a node that's 17 and connected to 27 and 29 tells people that it's 14 I mean you don't want that it's hard enough to do when you tell the truth so don't cheat this you know there's probably a variant of this we can come up with where some fraction of the nodes they're adversarial and then you can see if this stuff even works but right now don't cheat if you've got a slip you kind of have to really try to participate in whatever protocol you come up with and this experiment has no human subjects approval okay so it does um who has the envelope is it empty oh my goodness at seven minutes already let's okay well when the envelope gets empty we can start this thing so we should try to move it along is everyone clear on the rules what you're trying to do is to find a path between a node that the source node which was numbered one and the destination node enough that was number forty the source and the destination know who they each are and then we'll just gonna wait this is the easiest lecture to prepare for because I just have to keep quiet for a few minutes okay and if things all work out or things don't work whatever it is I'm assuming that you'll come up with some variant of the reasonable routing protocol and odds are it will be a variant of one of the ones we're going to study you know the general hero's suggest if something was a reasonable idea which is you go and you know you you do one you tell you you know you pick one neigh​bor and you go through but you get stuck in a loop and then the idea is you come back to where you start and then you go through the next and that principle could work but you gotta remember a lot of stuff and tends to make mistakes in fact you know this was an easy Network where every node had one two or three neigh​bors I mean as a few with more but most of them had a small number of neigh​bors what you guys were going after was a sort of better plan which is everybody yells out the neigh​bors and the day as yell out their neigh​bors and their neigh​bors and so forth and that particular protocol has a nice name to it it's called link state routing where you broadcast and flood your own neigh​bor information okay that's the second of the two protocols we're going to study what you were trying to go after was a link state routing now the first protocol we're gonna study has a different name to it it's called distance vector re and these are the two routing protocols we're going to study almost all routing protocols and practice are variants of either a vector protocol or one of these link-state protocols there's lots of variants but these cover and there's hundreds of routing protocols but these cover the main concepts so let me tell you how this is our distance vector protocol or how the vector protocols works they're a little different from the kind of approach you were going after in solving this problem had you gone after an approach where you started at the destination at 40 and 40 simply said I'm 40 and then the neigh​bors next to 40 then said I'm connected to 40 to get to 40 come through me and the cost is let's say whatever the cost of their link to 40 is right then now initially nodes only knew about themselves but now you have a destination and you have a set of nodes connected to the destination let's call these nodes let's just say n1 n2 and n3 initially the only thing that D says is I'm D and it says back to its neigh​bors along these links the same has a name to it it's in it's an advertisement now when anyone hears about destination D it can do the same thing to its neigh​bors so let's say these are n4 and n5 here what n1 can do is to say that to get to D let's imagine that this cost here is 6 so D says I'm D and the cost to get to me is 0 because I'm D n1 says here's that and it says I'm n1 that's true but to get to D come through me and the cost is 6 so it now puts out advertisements along these links but it says D : 6 6 6 where 6 is the cost of that link and now let's imagine that you know these other links have cost so let's say this link has a cost of eight this link has a cost of two let's say this link has a cost of 9 so the link cost is eight the link cost is nine and the link cost is two and let's say for a minute here that this cost of this link is there now n1 advertises to everybody saying to get 2d the cost is six to get 2d the cost to six and they get to get 2d the cost of six each of those guys when they get this information now know that they can get a route to destination D because now and for now is that if it used this link to get 2d the cost would be six plus the cost of that link so it's 14 so it would have a routing table entry that says D is a cost 14 and of course the routing table entry would have an entry saying this is the link that it should use similarly n5 here would take destination D and say that the cost to destination D is 9 plus the advertisement which was 6 and so it would say D is 15 and n 2 which previously had her out today which was this link that cost 10 would look at this new advertisement coming in here saying that the cost on this from n1 is 6 add that cost to the cost of the link which is 2 and have now a different way to get to D whose cost is 8 and compared that cost against the cost a previously held to the destination D and because we're interested in minimum cost routing 8 smaller than 10 so n 2 would previously which had previously had a cost to destination D of 10 would throw that route out replace it with a route the destination D going along this link with the cost of now eight which is smaller than ten and this process just continues through as it goes along so you might end up in a situation quite easily as we just went through here well let's say n 3 will connected to n 5 if this link had a cost of 1 in this link at a cost of 4 what would eventually happen is that n 5 which ended up with the cost of 15 to go like that would when it here's an advertisement from this node replace that route with a cost of 4 and use this link as its route to get to get the destination D and this process just continues until everybody has initially some route to D and then if the process continues a little bit longer everybody will have a minimum cost route to D this step where nodes evaluate an advertisement that they hear about a destination against their current route and the current cost to the destination and replace it if they end up finding a route with smaller cost or an advertisement with smaller cost when you the cost you have to compare is the cost of the advertisement plus the cost of the link along which that advertisement came and you compare that cost against the cost of the route you already hold if it's smaller you replace it that algorithm is called the bellman-ford algorithm and you might have seen centralized implementations of shortest path routing using this algorithm and if you have it actually turns out it's a little less efficient than other algorithm another one we'll study called Dijkstra's if you're doing it centralized but it's very very elegant elegant for distributed computation because the routes to different destinations are being computed in a completely distributed way these nodes far away here have no idea what the network topology looks like they couldn't even reconstruct the network topology the best they could do is to find their own way to get you know their link to use the only information they have is what they hear from their neigh​bors but yet they're able to find an answer because all they have to do is to listen to all their neigh​bors and among the set of neigh​bors pick that neigh​bor whose advertise cost plus the cost of the link to that neigh​bor is minimum across all of the neigh​bors so the computation that's being done is a very simple computation very elegant computation which is the main over all of the neigh​bors of the link cost lij plus the advertised cost from j where the minimum has gone over all are all j where j is the set of neigh​bors so you minimize over the set of the neigh​bors each node I does this you minimize over the set of neigh​bors J of I the link cost from I to J plus the advertised past to destination D of J and take the minimum cost that's the minimum cost and then you take the link corresponding to that neigh​bor and that's the route that you use now this algorithm gets more complicated and tricky to argue that it's correct when there are failures but today there are no failures there's some other wrinkles in the algorithm which is I mentioned that you know what are the conditions under which a link node changes its route to a destination so I went through one rule I I mentioned a rule that said if the current copy if the current route to the destination does not exist in which case the cost is assumed to be infinity or if the current cost to the destination is smaller than the cost of the advertisement plus the cost of the link along which the advertisement came then you replace the route to the destination but there's actually one other condition under which you should replace the route to the destination if it's equal well technically you don't have to replace it you still have a good pad right you could replace it but it doesn't matter there might be a case where you have to replace the link the route when and when in fact the cost increases there might be a case where you hear a you you have a current cost to the destination and some current route to the destination and you hear an advertisement and you take that advertisement and you add the link cost and you find a bigger number and you might sometimes have to replace it yes right it could be that what's going on here is that the cost to the destination you know a link I might I previously told you that my cost to the destination is 17 and now I've changed my mind I tell you that it's actually 19 and I could change my mind for a variety of reasons usually having to do with failure so I guess this is a little bit of a cheating question because I told you there's no failures but it could be that perhaps you know the cost of a link changed because it became more expensive or something like that and that's the only subtle case you have to worry about where a cost of only the advertisement could could increase and if that cost increases along your current route like you think that the route to the destination is 17 the cost is 17 but in fact it turns out to be you know 24 that's the time when you have to change your entry in the routing table you have to change the cost associated with it but otherwise it's basically that's the algorithm and it's summarized over in this in the stable I in this chart here and I've gone through pretty much all of it does anyone have any questions no questions how long does it take before every node in the network actually before I get to that the reason it's called a vector protocol is I showed you a picture for one destination but in fact each switch or each node does it for all destinations so the general form of a distance vector advertisement looks like this it has a destination destination 1 : cost one destination to Poland cost to destination 3 : cost 3 and so forth for all the destinations to which you have a cost and initially when you start you don't know about all of any of the other nodes if you have a route to some destination in general then there's some cost associated with it if you know about a destination but have no route to it the cost is infinity it'll turn out next week will find that the value of infinity in this network has to be pretty small but that's because the sarvam is not the world's best algorithm for big networks and I'll explain why infinity has to be a small number but theoretically we can assume it's infinite the reason it's called a vector protocol is because the advertisements are a vector of this destination cost tuples and so you send these tuples around and this is a vector of these tuples and hence this is called a vector protocol it really should be called cost vector protocol but initially they ran this thing where all of the links had cost of one where and therefore they were minimizing distance and the name stuck but if we wanted to be perfectly precise we would say cost vector but then no one else in the world would understand what you meant so we say distance vector okay any questions all right how long does it take before every node in the network for some destination how long does it take before every node in the network has a route to that destination where by how long I mean how many advertisement cycles do you have to go through how many how many of these advertisements like initially let's say that the way our world is going to work is initially every node advertises its own advertisement to itself then at the next time step every node advertises their arts that it knows about and then it does that periodically so let's say that every T seconds a node sends out an advertisement where an advertisement basically contains this tuple of this the spec vector of tuples for all of the destination it knows about right so let me explain this protocol again and then I'll ask you the question the protocol is very simple every T seconds what what the nodes doing is looking at two columns in the thriving table it's looking at the destination column and the cost column and it's just taking that information out and it sends out an advertisement the distance okay every T seconds how long does it take now let's focus on one destination D some destination D in the network and you have some network how long does it take before every node has some route to the destination yes up to the number of edges in my network all right so let's say you have a network that looks like this how long does it take before every node has a route to destination be there for well I'm asking for an answer that holds for all networks not for sure in the worst case it could well yes in the absolute worst case it is true that it'll always take time smaller than the number of edges in the network but you can come up with a much better bound so let's try to come up yes sir longest length chain so that's not completely to the longest what kind of longest length because you could have a really so another counter example let's say that I have this network the longest length chain is 1 2 3 4 5 6 but yet you guys just told me that in one shot you get the answer so you have to clarify what you meant a little bit you're almost right I said find a path or find a route not the best route how long does it take to find a route and network you said this almost the longest path but it's not quite the longest path it's the longest something bad yes the longest shortest path that is the longest path with the minimum number of the longest path when you compute the longest overall paths with a minimum number of hops between one place to another that's also called the diameter of the network okay yes yes okay all right now that's the time it takes a multiply by T and I might be off by one you know it's one minus that minus one actually it's not it is the number of hops along the longest shortest path now how long does it take to find the minimum cost path - there - to some destination D at all of the nodes what three times no that's that's true that you can find it within that oh that's too long so I'm gonna come back to this question it's probably answered in my in one of the chilla too in chapter 18 I think but we'll come back to that next time it'll become a little bit clearer but you should think about it there's a nice succinct answer to this question and generally speaking in every quiz there's some variant of this question so you know it's not explicit but there's some story that looked wise if yes you have an answer oh you do okay I'll come back to that question next time but yes yeah I can go over that so let's say you have here you look at this destination beam and you look at from every node what's the path with the smallest number of hops number of hops not cost path with the smallest number of hops to get to that destination right so this guy it's one two three four this guy it's one two three etc whatever that biggest number is multiplied by T is the answer that's how long it takes before every node here some pack but it's not quite the right answer for the best path because as you saw in this example here it took us one step before n to God a proud to the destination but it took us two time steps before it got its best route to the destination and the reason was that has something to do with the length of the minimum cost path right because in this case the length of the minimum cost path is two plus six eight it took two hops which is different from the length of some shortest hop path which was one half so if I look at this picture and to here's about some route to the destination in the first advertisement but then to find its best route to the destination requires us to actually wait around until we find this two plus six path which took two hops so it's a little longer but it's not like enormously long it's just a little bit longer and the answer of course depends on in the worst case it could be quite long but it depends on the number of hops along the minimum cost path and if you minimize that quantity you find the answer to the question how long does it take before every node finds the minimum cost path to the destination okay is that clear any questions about distance-vector crystal fear okay we'll see when the lab comes around it is crystal everybody really really does well in the slide in these labs it's a lot of fun hacking the stuff up so your Olympic medals and you'll actually look at all sorts of failures and it'll just be sometimes miraculous that it actually works even when you didn't consider some failure cases okay now I'm going to talk about link state routing and this is the routing protocol that you guys were sort of attempting to implement attempting to come up with this is a radically different approach from the vector protocols in a vector protocol everybody advertises for each destination a vector of tuples where it's the destination and the cost in a link state protocol we don't do that the link state protocol does not compute in a distributed way in a link state protocol every node just says I am node 17 and I am connected to 1645 and 44 and the cost of my link to 16 is 7 the cost of my link to 45 is something and the cost of my link to this other neigh​bor that I have is something else so every node advertises what I've shown up on the slide every node advertises a neigh​bor it's immediate neigh​bor and the link cost to that neigh​bor okay in addition in each of these link state advertisements there is a sequence number the sequence number starts at some initial value like say zero and every time one of these link-state advertisements is sent and that's done periodically as well every T seconds every time you send a link state advertisement you increment the sequence number by one now here's the key step the key step here is that when a node receives if I receive a link state advertisement from you I just send that to my neigh​bors and then my neigh​bors will send it to their neigh​bors and so on so it's a very this nice flooding protocol every node sends out its link state advertisement and every neigh​bor that receives it processes that and then turns around and ships it to their neigh​bors and they do the same thing to their neigh​bors and so forth now when this flooding process completes and every node is originating its own link-state advertisements so you're telling them you know your neigh​bors who you're connected to she's telling her neigh​bors who she's connected to and we all do that and we're all doing this in parallel it's all happening at the same time and all our neigh​bors are rebroadcasting this and eventually every nodes going to get one or more copies of every link state advertisement which means that every node can now construct an entire map of the network every node can construct this entire graph and once they construct that graph every node can implement some shortest path routing protocol to compute the paths over that graph this is very different from the previous protocol in vector routing protocols the nodes actually have no idea what the topology of the network is all they know is and they trust what the neigh​bors tell them here every node has complete knowledge under the basic model every node has complete knowledge of the overall network topology so let me show this by example become completely clear so let's imagine that this is what the network looks like and you start I'm going to show you a picture of no death no deaf originates its initial link-state advertisements a day Iseman it increments the sequence number by one and it says I am connected to G with no G with a cost of eight and the node C with a cost of two and it spits it out to its neigh​bors each of those neigh​bors turns around and does the same thing you rebroadcast a link-state advertisement along the links that you're connected to and they rebroadcast it and so forth and eventually be get said and he broadcasts it too though it was completely useless to do so well not completely packets are lost it's pretty useful anyway when this flooding completes which takes you know some number of steps every node now has at least one if no packets are lost every node has a bunch of copies of this link state advertisement if packets can get lost as long as the loss rates are not you know enormous every node might have one copy of a link state advertisement and now every node originates its own link-state advertisements and therefore they end up with a map of the network by the way why do we have the sequence number in the link state advertisement yes yes that is one of the two reasons why you have it that's actually the second reason the main reason you have and that's a valid reason but the main reason you have it is that if si gets a link-state advertisement originating from F with sequence number 17 and then eventually C is also going to get D rebroadcasting that link-state advertisements ends it this way but F also sends it this way and that goes up here and that comes down here and then D rebroadcast said C needs a way of telling whether this link-state advertisement is new or old right and the way it tells if it's new or old is it considers the link-state advertisements bigger than the last sequence number it received from that origin so now every note has a map of the network and now we run this integration step where we actually take this map of the network and we find shortest paths to the network I need a show of hands how many people know how Dijkstra's algorithm works from how many people don't know how it works all right what I'm going to do is it's described very well in the notes we've talked about in recitation tomorrow but I'm going to show it by example and then we'll come back to this again on Monday but I'm going to tell you this now because you kind of need it for the lab and it is just that very well in the readings and we'll do it in recitation as well so here's how it works let's imagine we want to find paths from a to all of the other nodes in the network now initially a doesn't know paths to anyone except for itself but what a nose is this map of the network and what is trying to do is to find routes to all the other destinations the way does that is it keeps building up in non decreasing order of the cost of the minimum cost path to the destination it starts building up information about the routes to the different destination so initially it looks the stable and it says it's connected to C and it's connected to B with a cost of six so what it does is it says all right among all of the people out here I'm going to pull in the person with the minimum that minimum cost path and it might pick in this case it might just pick the node C because between C and B it doesn't matter which one it takes now the cost to all of the other guys is considered to be infinity so it has costs of six and six so it pulls in one of them by without loss of generality it just picks one of them and now it has cost to both of them and it says that the route from a itself at a the route to see is this link what it then does is it goes and looks at all of the neigh​bors connected to a and C and in fact it only has to look at the New Nordic pulled in and it has to adjust the cost of the minimum cost path to the destination that's connected to that in this case it adjusts from infinity it brings down the cost to be to 13 because it knows that it can get to C is 6 6 plus 7 is 13 similarly it does that for e at 10 and then it does that to F at 8 so now it has costs of 66.6 is already in 6 13 10 and 8 and infinity so now it has to decide what node to pull in next and it pulls in the node with the minimum cost among the costs that you have so far and that's this node over here so it pulls that in if my wireless works there we go and then once it pulls that in it adjusts the route to that to be the green link and then it goes ahead and looks at the neigh​bors of B and it adjusts the shortest path cost in this case that 13 now becomes 11 because 6 plus 5 going through B is shorter than 6 plus 7 going through C and now it repeats it pulls down the minimum the minimum of this case is 8 it pulls in F makes that be the route to F now the route to F is not that link the route to F is in fact this link at the routing table but it knows that because it knows that F is connected to C and therefore the route to F is equal to the route to the parent which is C's therefore in the throttle table entry it makes the route to FB that link which is exactly the link to C so that's the subtlety you have to keep in mind when you implement this stuff in the lab it goes ahead and adjust that to 16 it now pulls the minimum which will be 10 and then adjusts the cost of the guys connected to it so D becomes D changes to 10 and then it now goes ahead and pulls the minimum in in this case it's 12 its D with a cost of 10 that's the link to use and that link there for the route to D is the same as there are two e there are two E's the same as there are two C which is that link and now you finally conclude the algorithm by getting that last node here so I'm going to stop here that was Dijkstra's algorithm and the two routing protocols we will pick it up in recitation